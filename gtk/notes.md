# Outline for GNOME-Specific Part of the Presentation

- GNOME (https://www.gnome.org/)
  - Most popular desktop environment for Linux; most desktops (Fedora, Ubuntu, OpenSUSE etc.) all ship GNOME out of the box
  - Fully free software (GPL/copyleft) for 100% of it
  - When you use "Linux", the system you're most likely to interface with as a user is GNOME
  - Founded in 1997 (https://www.gnome.org/about/) and has since grown into a massive project
- The GNOME HIG (https://developer.gnome.org/hig/)
  - Writing apps for GNOME means writing apps that confirm to GNOME's human interface guidelines
  - They give your guidance on everything from how apps should be named, icons should look like, how colors and fonts should be used, and how applications should be laid out
  - GNOME feels very Apple-like at times, and this consistency is why
  - While it's usually referred to as a "desktop environment", GNOME apps and GNOME itself is adaptive - it's optimized for all Linux devices, including phones and tablets
  - That means GNOME apps are responsive/adaptive, meaning they run on desktops, tables and phones (e.g. postmarketOS: https://postmarketos.org/)
  - Has multiple sections
    - Design principles: Basic design rules and goals for the GNOME platform
    - Resources: Tools and assets that are available for GNOME design work
    - Guidelines: Conventions that are used in GNOME UX design
      - How to write text
      - Icons
      - App identities
      - Handling different types of input.
    - Patterns: Elements from which designs can be composed
      - Windows
      - Buttons
      - Notifications
      - View switchers
    - Reference: Keyboard shortcuts and UI colors.
  - Go through the sections in the sidebar on https://developer.gnome.org/hig/ one by one, esp. which components are available (@Violet: Please include some screenshots)
- GTK and GNOME
  - GNOME provides many libraries - GTK, GDK, Soup, Camel, ...
  - These provide the core building blocks for building a desktop environment
  - GTK itself is fairly neutral design-wise, and the GNOME HIG is implemented on top of GTK with a library called Adwaita
  - Adwaita is an implementation of the GNOME HIG using GTK
  - Other desktops, like elementaryOS, also use GTK, but implement their own design system on top of GTK for elementaryOS, Granite: https://docs.elementary.io/hig)
- GNOME application structure compared to web applications
  - Let's get started looking at how apps are structured!
  - FQDNs
    - Apps need to have global, world-unique IDs
    - Similar to domains, but backwards
    - For example, for today's example that will be `com.pojtinger.felicitas.VanLUGNews`
  - Blueprint/XML files for layout (the "HTML" of GNOME) (https://github.com/pojntfx/vanlug-talk-2026-linux-app-development/blob/main/gtk/examples/js/window.blp)
    - Defines the structure of the application - buttons, widgets, webviews and so on
    - Defines no logic, just how the application is structured
    - Some style is defined (layout etc.), unlike how it is done in HTML in the web
    - There can be multiple, e.g. one for the main window, one for the login screen, one for the settings
    - Are "bound" to a class that implements logic
  - CSS for styling (it's just regular CSS) (https://github.com/pojntfx/vanlug-talk-2026-linux-app-development/blob/main/gtk/examples/js/style.css)
    - Just like on the web, for GTK CSS is used to style how applications look like
    - Same CSS as on the web with very minor changes (mostly missing features) - uses CSS selectors and everything
    - All of GTK and Adwaita is just CSS stylesheets (https://gitlab.gnome.org/GNOME/libadwaita/-/tree/main/src/stylesheet)
    - You can add your own stylesheets on top of that to change how your application behaves
  - main.js/main.py etc. for the actual logic (https://github.com/pojntfx/vanlug-talk-2026-linux-app-development/blob/main/gtk/examples/js/main.jsk)
    - This is where all of the application logic is
    - It's where you load the CSS files and connect the Blueprint files to the classes
    - E.g. if you have a button, this is where you connect that button to do something
  - GResources for loading any static assets in the application (icons, sounds, etc.) (https://github.com/pojntfx/vanlug-talk-2026-linux-app-development/blob/main/gtk/examples/js/index.gresource.xml)
    - This is where you reference your Blueprint and CSS files, images, sounds etc. and build them into a binary bundle
    - That binary bundle is then loaded when your app launches
    - Instead of referencing e.g. a blueprint file relative by it's path when the application launches (which is fragile since the paths change depending on where you install the app), you instead reference the file/resource you'd like to access with `FQDN/relative path`
  - po/gettext for i18n (POTFILES, default.pot, Weblate) (https://github.com/jwijenbergh/puregotk/blob/main/examples/myapp-gnome-meson/po/myapp-gnome-meson.pot)
    - Applications need to get translated/adapted ("localized"/"internationalized")
    - A system called gettext is used for this
    - You use a gettext library to access localized versions of a string in your source code and/or Blueprint files (e.g. `_("Hello")` → `你好`)
    - `xgettext` then scans your source files (listed a file named `POTFILES`) for the `_(...)` pattern and writes all the strings that it found and where it found them to a `po/myapp.pot` file
    - You can then use that `.pot` file as a template to add translations to your apps (e.g. https://github.com/jwijenbergh/puregotk/blob/main/examples/myapp-gnome-meson/po/fr_CA.po)
    - Meson etc. will then compile those `.po` files into `.mo` binary files, install them in a well-known location, and parse them at runtime to get the translated files for you
    - Gettext is so widely used that there is a very vibrant ecosystem of apps that you can use to contribute translations
    - For editing files, [Translation Editor](https://flathub.org/fr/apps/org.gnome.Gtranslator) can be used
    - For more advanced workflows, Weblate (https://hosted.weblate.org/projects/sessions/) can be used (demo with Sessions) - no need for technical knowledge, anyone can translate into their language with a browser
    - GNOME itself uses it's own platfor, "Damned Lies" (https://l10n.gnome.org/)
  - Mallard for integrated files (f1 to open) (https://gitlab.gnome.org/World/highscore/-/blob/main/help/C/duck/opening-games.duck)
    - Integrated help that you can ship with apps
    - Will be available offline and serves an embedded handbook
    - A bit outdated/old-fashioned, but still very useful IMHO
    - Demo by pressing F1 in nautilus
  - GSchema and GSettings for settings (dconf/registry-style)
    - You can use config files to configure things on Linux, and those work well
    - But sometimes you want to have proper static typing and a centralized way to store everything, which is what GSchema is for
    - First you define a schema and include it in your GResource file (https://github.com/pojntfx/multiplex/blob/main/assets/resources/index.gschema.xml)
    - Then you can simply access them as GTK properties from app (https://github.com/pojntfx/multiplex/blob/main/internal/components/preferences_dialog.go#L98-L116)
    - And bind your inputs to the values (https://github.com/pojntfx/multiplex/blob/main/assets/resources/preferences.blp)
    - You can use dconf-Editor to look at all the schemas you've installed (show dconf-editor for the Multiplex schemas as an example)
  - Meson configuration
    - Root meson.build (https://github.com/jwijenbergh/puregotk/blob/main/examples/myapp-gnome-meson/meson.build)
      - Defines language and version
      - Adds any arguments to the project as a whole
      - Imports i18n and GNOME meson modules
    - po/meson.build (https://github.com/jwijenbergh/puregotk/blob/main/examples/myapp-gnome-meson/po/meson.build)
      - Defines i18n setup
      - Configures keywords that are used to access internationalized strings
    - src/meson.build (https://github.com/jwijenbergh/puregotk/blob/main/examples/myapp-gnome-meson/src/meson.build)
      - Writes metadata like versions and where compiled i18n files are stored to a source file (C/Go/JS etc.) that can be accessed at runtime
      - Defines dependencies on other (C) libraries
      - Compiles Blueprint and GResource files
      - Builds the app main entrypoint itself
  - Flatpak manifest (more about this later)
- GTK application structure (GObject, signals, properties, methods etc.)
  - GObject System (https://docs.gtk.org/gobject/tutorial.html):
    - Adds language-independend/C-based object system/OOP
    - Defines things like types and classes, objects, subclassing and so on
    - Is the reason why GTK is usable from so many languages
    - All classes inherit from GObject.Object
  - Widgets (https://docs.gtk.org/gtk4/class.Widget.html)
    - Base component that can be rendered to the screen in GTK
    - All GTK components - buttons etc. - all inherit from Gtk.Widget
  - Methods (example: https://docs.gtk.org/gtk4/class.Button.html#methods)
    - Allows defining a method on a class that can be called
    - For example, to set the icon of a button, you can call `Button.set_icon_name` (https://docs.gtk.org/gtk4/method.Button.set_icon_name.html)
  - Signals (https://docs.gtk.org/gobject/signals.html)
    - Allow emitting events from an object
    - Useful if you want to attach to an event like "button has been clicked" - connect to the "clicked" signal and your function will be called by GTK
  - Properties
    - Can be readable or read-writable
    - One object's property can be bound to another object's property automatically (so that when you flip a switch, an image becomes visible or invisible with less boilerplate)
    - When using Blueprint, you're setting properties on each class (show Blueprint file with the docs open at the same time, e.g. ListBox in examples)
- Writing apps in different languages (JS, C, Go, Rust, Java, Python etc.)
  - Simple examples, single file with Blueprint file and CSS (mention the others later, and use libadwaita autoloading for resources via GResource)
  - https://vanlug.ca/ has a RSS feed where articles are published
  - Live demo for JS and Python
  - Recreate by going through commits
  - JS example (https://github.com/pojntfx/vanlug-talk-2026-linux-app-development/tree/main/gtk/examples/js)
  - Python example (https://github.com/pojntfx/vanlug-talk-2026-linux-app-development/tree/main/gtk/examples/python)
  - C example (https://gitlab.gnome.org/GNOME/gnome-calendar)
  - Go example (https://flathub.org/fr/apps/com.pojtinger.felicitas.Sessions)
  - Rust example (https://codeberg.org/haydn/typesetter)
  - Java example (https://github.com/jwharm/java-gi-examples)
  - Lua example (https://github.com/vtrlx/tally)
  - Fortran example (https://github.com/vmagnin/gtk-fortran/tree/gtk4/examples)
- Writing reusable modules that work from any language with GIR
  - Defining a widget
    - WebView vs. custom widget as a way to add components that GTK or libadwaita don't already have
    - GTK snapshot API for fully custom, GPU-accelerated components (example: Sessions)
  - Building the library (https://github.com/jwijenbergh/puregotk/tree/main/examples/mylib-gtk-meson)
  - Generating the GIR file via the generator
  - Distributing as a Flatpak module
  - Reading documentation for installed libraries via Manuals
  - Generating bindings for your language or using introspection (https://github.com/jwijenbergh/puregotk/tree/main/examples/mylib-gtk-meson-go)
  - Using the reusable library (https://github.com/jwijenbergh/puregotk/tree/main/examples/myapp-gnome-meson)
  - Link to the FOSDEM talk I'll be doing (https://pretalx.fosdem.org/fosdem-2026/me/submissions/A8FZCD/)
- IDE setup (VSCode, GNOME Builder)
  - VSCode/VSCodium
    - VSCodium (https://vscodium.com/)
    - JS/C/Go/Rust/Java/Python extension
    - Blueprint extension (https://open-vsx.org/extension/sonnyp/blueprint-gtk)
    - Meson extension (https://open-vsx.org/extension/mesonbuild/mesonbuild)
    - Flatpak extension (https://open-vsx.org/extension/bilelmoussaoui/flatpak-vscode)
  - GNOME Builder (https://flathub.org/fr/apps/org.gnome.Builder)
    - Generating a new app using the IDE
    - Building and debugging
    - Preview: Foundry as a future tool (https://gitlab.gnome.org/GNOME/foundry)
  - GNOME Workbench (https://apps.gnome.org/fr/Workbench/)
  - Adwaita Demo, GTK Demo and GTK Widget Factory
  - GNOME OS reference platform (https://os.gnome.org/)
  - GTK Inspector (Ctrl + Shift + I, just like on the web) & adaptive preview (Ctrl + Shift + M)
- Maintenance
  - OSS maintenance and releases (keeping up with GNOME releases, deprecations etc.)
    - After your app has been published to Flathub, you need to now make sure to keep supporting it
    - Making sure to update your dependencies, merge new translations, respond to issues
    - When there is a new release of GNOME, you should make sure you follow the new HIG and switch away from deprecated APIs etc.
    - Doing releases, writing release notes, and responding to users is key
  - Submitting your app to GNOME Circle (https://circle.gnome.org/)
    - If your app works well, is maintainable and matches the GNOME mission in some way, submitting it to GNOME circle is a good idea
    - Once you're in GNOME circle, GNOME will advertise it for you, you can become a member of the GNOME foundation, and get access to build infrastructure etc.
    - In order for the app to be accepted, you need to match some quality criteria (https://gitlab.gnome.org/Teams/Releng/AppOrganization/-/blob/main/AppCriteria.md)
      - Technology & Design
        - Uses GTK 4 + Libadwaita with GNOME runtime on Flathub
        - Follows Human Interface Guidelines
        - Dark mode and high-contrast mode work correctly
      - Quality & Maintenance
        - Basic features work as expected, easy to get started
        - Evidence of recent development activity
        - No known issues that can lead to data loss
      - Accessibility
        - Full keyboard navigation with standard shortcuts
        - Works with Orca screen reader
        - Large text mode supported, sufficient contrast
      - Legal & Content
        - OSI-approved license, no CLA required
        - Works without proprietary software
        - Adheres to GNOME Code of Conduct
      - Metadata & Distribution
        - Valid app metainfo, proper naming and icon
        - Quality screenshots and summary
        - Content rating and hardware support info present
      - Meta
        - Available on Flathub for x86_64 and aarch64
        - Valid app ID format (the FQDNs we mentioned earlier)
        - No GNOME branding (until accepted)
        - Internationalization support
    - Also possible for libraries and tooling around GNOME with similar restrictions (see https://gitlab.gnome.org/Teams/Circle/-/blob/main/library_criteria.md)
  - Contributing directly to GNOME
    - Everything is welcome, not just code
    - Donations (become a friend of GNOME) - a subscription that actually matters: https://donate.gnome.org/
    - Code: https://welcome.gnome.org/fr/team/programming/
    - Design: https://welcome.gnome.org/fr/team/design/
    - Translations: https://welcome.gnome.org/en/team/translation/
    - Testing: https://handbook.gnome.org/testing.html
  - GNOME foundation membership and it's benefits (https://foundation.gnome.org/membership)
    - Vote in elections
    - Run for election
    - Propose changes
    - GNOME email addresses, Matrix accounts, Blogs, Nextcloud, Travel sponsorships and more
